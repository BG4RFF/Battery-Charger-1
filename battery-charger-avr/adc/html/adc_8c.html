<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AVR A/D Library: adc.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul>
</div>
<h1>adc.c File Reference</h1><code>#include &lt;avr/io.h&gt;</code><br>
<code>#include &lt;avr/interrupt.h&gt;</code><br>
<code>#include &quot;<a class="el" href="adc_8h-source.html">adc.h</a>&quot;</code><br>

<p>
Include dependency graph for adc.c:<p><center><img src="adc_8c__incl.png" border="0" usemap="#adc.c_map" alt=""></center>
<map name="adc.c_map">
<area shape="rect" href="adc_8h.html" title="adc.h" alt="" coords="147,107,208,133"></map>

<p>
<a href="adc_8c-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionadcUnion.html">adcUnion</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#a8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#a93f0eb578d23995850d61f7d61c55c1">FALSE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#20694d180636e2fefc77d6ea4f8a61b1">writeAdmux</a> (uint8_t channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the current ADC channel to the Multiplexer register.  <a href="#20694d180636e2fefc77d6ea4f8a61b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#4341d9fc092ff33a2a6915c5440479e7">adcInit</a> (uint8_t mode, uint16_t adcClock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise A/D conversion process.  <a href="#4341d9fc092ff33a2a6915c5440479e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#8ee546a9cf8ade9b001f2843d8b9444c">adcStart</a> (uint8_t channelMask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an A/D conversion.  <a href="#8ee546a9cf8ade9b001f2843d8b9444c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#7ed8a34f66a31724ad1b980d64549195">adcIsBusy</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check Progress of an A/D conversion.  <a href="#7ed8a34f66a31724ad1b980d64549195"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#39e059b709db5993180b856cef0fc5ff">adcRead</a> (uint8_t channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the result of the A/D conversion.  <a href="#39e059b709db5993180b856cef0fc5ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#dd4bc11fc41d4a32b90186575da0cac0">abortConversion</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort any running A/D conversion.  <a href="#dd4bc11fc41d4a32b90186575da0cac0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#e5a854f2d1781f11ebf5f9d1c8e5d127">SIGNAL</a> (SIG_ADC)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupt Service Routine.  <a href="#e5a854f2d1781f11ebf5f9d1c8e5d127"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static union <a class="el" href="unionadcUnion.html">adcUnion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#6991c7bbcce4aad43a90312fccdde87f">adc</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static volatile uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#883a2c17ff3bb2ba7657edfdbca16c51">adcDataValid</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static volatile uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#dd7e48743af8fbde7e615a5f46a98bfc">adcBusy</a> = FALSE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static volatile uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#b889735af2869e3ce02c3a027b348e94">adcValue</a> [NUMBER_OF_ADC_CHANNELS]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static volatile uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#4cda2ae0c5ac82065b23cadd4843a34b">adcChannel</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static volatile uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#eba44105ae8656f3c7dff15b852af986">adcMode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static volatile uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc_8c.html#2d2c09f30fb85b71f5b4cb23437325ab">adcScanMask</a></td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a93f0eb578d23995850d61f7d61c55c1"></a><!-- doxytag: member="adc.c::FALSE" ref="a93f0eb578d23995850d61f7d61c55c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FALSE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="adc_8c-source.html#l00067">67</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
Referenced by <a class="el" href="adc_8c-source.html#l00130">adcInit()</a>, <a class="el" href="adc_8c-source.html#l00321">adcRead()</a>, <a class="el" href="adc_8c-source.html#l00220">adcStart()</a>, and <a class="el" href="adc_8c-source.html#l00415">SIGNAL()</a>.
</div>
</div><p>
<a class="anchor" name="a8cecfc5c5c054d2875c03e77b7be15d"></a><!-- doxytag: member="adc.c::TRUE" ref="a8cecfc5c5c054d2875c03e77b7be15d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TRUE&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="adc_8c-source.html#l00066">66</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
Referenced by <a class="el" href="adc_8c-source.html#l00130">adcInit()</a>, and <a class="el" href="adc_8c-source.html#l00220">adcStart()</a>.
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="dd4bc11fc41d4a32b90186575da0cac0"></a><!-- doxytag: member="adc.c::abortConversion" ref="dd4bc11fc41d4a32b90186575da0cac0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void abortConversion           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Abort any running A/D conversion. 
<p>
This will simply disable the ADC. Useful for stopping a free running conversion. 
<p>
Definition at line <a class="el" href="adc_8c-source.html#l00388">388</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
References <a class="el" href="adc_8h-source.html#l00188">outb</a>, and <a class="el" href="adc_8h-source.html#l00191">sbi</a>.
</div>
</div><p>
<a class="anchor" name="4341d9fc092ff33a2a6915c5440479e7"></a><!-- doxytag: member="adc.c::adcInit" ref="4341d9fc092ff33a2a6915c5440479e7" args="(uint8_t mode, uint16_t adcClock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t adcInit           </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>adcClock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialise A/D conversion process. 
<p>
This function forces the A/D converter to prepare for conversion from a reset state. Once it has been initialized, it can continue to be used for a series of conversions using the same clock rate and mode.<p>
ADC_DYNAMIC_CLOCK indicates whether the clock rate is defined in code or in a C macro. In the former case, it can be changed on the fly by the program if needed. Most of the time a fixed rate is adequate.<p>
Assumes that the ADC is not busy on a conversion. This should be tested first before calling this if changes to mode or rate are to be made on the fly.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>Bit 0 Free Running conversion (0 = Single conversion) Bit 1 Interrupts (0 = Polled) Bit 2 Power down, noise "cancellation" mode All other bit settings ignored. Note: Sleep mode is ineffective if more than one conversion occurs. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>adcClock</em>&nbsp;</td><td>in kHz. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successfully initialized, </dd></dl>

<p>
Compute and set the ADC prescaler bits if dynamic clock is selected. 
<p>
Definition at line <a class="el" href="adc_8c-source.html#l00130">130</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
References <a class="el" href="adc_8h-source.html#l00185">_BV</a>, <a class="el" href="adc_8h-source.html#l00246">ADC_PRESCALER</a>, <a class="el" href="adc_8c-source.html#l00093">adcBusy</a>, <a class="el" href="adc_8c-source.html#l00097">adcMode</a>, <a class="el" href="adc_8h-source.html#l00190">cbi</a>, <a class="el" href="adc_8h-source.html#l00027">F_CPU</a>, <a class="el" href="adc_8c-source.html#l00067">FALSE</a>, <a class="el" href="adc_8h-source.html#l00045">FREERUN</a>, <a class="el" href="adc_8h-source.html#l00047">INTERRUPT</a>, <a class="el" href="adc_8h-source.html#l00188">outb</a>, <a class="el" href="adc_8h-source.html#l00191">sbi</a>, and <a class="el" href="adc_8c-source.html#l00066">TRUE</a>.
</div>
</div><p>
<a class="anchor" name="7ed8a34f66a31724ad1b980d64549195"></a><!-- doxytag: member="adc.c::adcIsBusy" ref="7ed8a34f66a31724ad1b980d64549195" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t adcIsBusy           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check Progress of an A/D conversion. 
<p>
This function will return TRUE if the ADC is busy converting.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if busy </dd></dl>

<p>
Definition at line <a class="el" href="adc_8c-source.html#l00293">293</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
References <a class="el" href="adc_8c-source.html#l00093">adcBusy</a>.
</div>
</div><p>
<a class="anchor" name="39e059b709db5993180b856cef0fc5ff"></a><!-- doxytag: member="adc.c::adcRead" ref="39e059b709db5993180b856cef0fc5ff" args="(uint8_t channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adcRead           </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the result of the A/D conversion. 
<p>
Reads a result back from the A/D converter, returning -1 if the result is not ready. This function is non-blocking to allow mainline code to use an RTOS or other scheduling method.<p>
Blocking can be implemented simply by placing the call in a loop. On multiple channel scans it would be wise to poll each channel in the same order as the ISR uses, that is, lowest to highest. Be careful of free running mode as the first channel is scanned twice immediately after activation.<p>
The variable adcValid acts as a status indicator for the channel data. The ISR will set the bit corresponding to the specified channel when the data has been accessed (irregardless of whether the bit is already set), and the read function will clear it. This allows the ISR to signal the availability of the data, particularly during free running mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>the channel result to be read. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>8 or 10 bit result, or -1 if no result is available </dd></dl>

<p>
For polled operation, we first check the completion flag to see if anything interesting has happened. Then just do what the ISR would have done. This section of the code is effectively independent of the actual channel data access that the function is purposed to do. We just take the opportunity here to update our results.<p>
Look for the next channel by shifting adcScanMask until the first bit is a 1, to get the next channel in order.<p>
If the data valid flag mask is zero for the particular channel bit, do nothing more. Otherwise clear the valid data mask and return the result. 
<p>
Definition at line <a class="el" href="adc_8c-source.html#l00321">321</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
References <a class="el" href="adc_8h-source.html#l00185">_BV</a>, <a class="el" href="adc_8c.html#6991c7bbcce4aad43a90312fccdde87f">adc</a>, <a class="el" href="adc_8c-source.html#l00093">adcBusy</a>, <a class="el" href="adc_8c-source.html#l00084">adcUnion::adcByte</a>, <a class="el" href="adc_8c-source.html#l00096">adcChannel</a>, <a class="el" href="adc_8c-source.html#l00092">adcDataValid</a>, <a class="el" href="adc_8c-source.html#l00083">adcUnion::adcInt</a>, <a class="el" href="adc_8c-source.html#l00097">adcMode</a>, <a class="el" href="adc_8c-source.html#l00098">adcScanMask</a>, <a class="el" href="adc_8c-source.html#l00095">adcValue</a>, <a class="el" href="adc_8c-source.html#l00067">FALSE</a>, <a class="el" href="adc_8h-source.html#l00045">FREERUN</a>, <a class="el" href="adc_8h-source.html#l00186">inb</a>, <a class="el" href="adc_8h-source.html#l00047">INTERRUPT</a>, <a class="el" href="adc_8h-source.html#l00191">sbi</a>, and <a class="el" href="adc_8c-source.html#l00469">writeAdmux()</a>.
</div>
</div><p>
<a class="anchor" name="8ee546a9cf8ade9b001f2843d8b9444c"></a><!-- doxytag: member="adc.c::adcStart" ref="8ee546a9cf8ade9b001f2843d8b9444c" args="(uint8_t channelMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t adcStart           </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>channelMask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an A/D conversion. 
<p>
This function will initiate conversion of a group of channels defined by the channel mask. It makes use of parameters set by the adcInit function. All channels represented by the channelMask are scanned consecutively. The first conversion after initialization is slightly different to any later ones, as it takes about twice as long. The ADC must be idle otherwise it returns a NOT_READY indication.<p>
The ISR will take over the initiation of consecutive channel scans. The recommended action for free running mode is to change the channel in the ISR as it is guaranteed to have allowed sufficient time for the converter to read its configuration. However this will cause the channel to be changed for the NEXT conversion, so we need to keep track of this.<p>
Using sleep mode along with free running mode is problematical for this library and is not practicable, even though it is not prevented. Here it will only sleep for the first conversion which is discarded anyway.<p>
The adcInit function must be called first. No checks are made on this.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channelMask</em>&nbsp;</td><td>the bit mask for channels to be read/scanned. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successfully started. </dd></dl>

<p>
Shift the adcScanMask until the first bit is a 1, to get the first channel to convert. In the ISR we can check if it is finished when adcScanMask becomes zero.<p>
Setup the sleep mode. Different MCUs have the controls in different registers, and generally mixed up all over the place. ATMegax8 have an SMCR register specifically for sleeping and power control, while others put these in the MCUCR register. Note that all three SM bits must be written to define the ADC Noise Control mode, and we do these separately because they can occur in different orders in the register for different MCUs. As noted, sleep mode is ineffective unless only a single channel is scanned once only, so that we must return here each time we want to do another scan. 
<p>
Definition at line <a class="el" href="adc_8c-source.html#l00220">220</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
References <a class="el" href="adc_8h-source.html#l00171">ADC_PORT_DDR_REG</a>, <a class="el" href="adc_8c-source.html#l00093">adcBusy</a>, <a class="el" href="adc_8c-source.html#l00096">adcChannel</a>, <a class="el" href="adc_8c-source.html#l00092">adcDataValid</a>, <a class="el" href="adc_8c-source.html#l00097">adcMode</a>, <a class="el" href="adc_8c-source.html#l00098">adcScanMask</a>, <a class="el" href="adc_8h-source.html#l00190">cbi</a>, <a class="el" href="adc_8c-source.html#l00067">FALSE</a>, <a class="el" href="adc_8h-source.html#l00186">inb</a>, <a class="el" href="adc_8h-source.html#l00188">outb</a>, <a class="el" href="adc_8h-source.html#l00191">sbi</a>, <a class="el" href="adc_8h-source.html#l00049">SLEEP</a>, <a class="el" href="adc_8h-source.html#l00197">SLEEP_REG</a>, <a class="el" href="adc_8c-source.html#l00066">TRUE</a>, and <a class="el" href="adc_8c-source.html#l00469">writeAdmux()</a>.
</div>
</div><p>
<a class="anchor" name="e5a854f2d1781f11ebf5f9d1c8e5d127"></a><!-- doxytag: member="adc.c::SIGNAL" ref="e5a854f2d1781f11ebf5f9d1c8e5d127" args="(SIG_ADC)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIGNAL           </td>
          <td>(</td>
          <td class="paramtype">SIG_ADC&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupt Service Routine. 
<p>
The ISR reads the result from the A/D converter and stores it in the appropriate result array location. A result flag bit is set to indicate what channels have been read and which are still to be completed. The next channel in a scan, if any, is selected and another conversion started.<p>
If freerun mode is active, then when a channel change is made, the conversion is already taking place and the change will not take effect until the next cycle. Therefore we must keep a record of the previous channel as the current conversion result will be for that channel, not the current one.<p>
The scan mask keeps a list of channels to be scanned. When a channel conversion is completed the mask is bit shifted to find the next channel. A flag is set for that channel in the adcDataValid byte. When the data is retrieved for the channel, that bit is reset. If data is not retrieved in time, it is overwritten by the next scan of the channel. 
<p>
Look for the next channel by shifting adcScanMask until the first bit is a 1, to get the next channel in order. 
<p>
Definition at line <a class="el" href="adc_8c-source.html#l00415">415</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
References <a class="el" href="adc_8h-source.html#l00185">_BV</a>, <a class="el" href="adc_8c.html#6991c7bbcce4aad43a90312fccdde87f">adc</a>, <a class="el" href="adc_8c-source.html#l00093">adcBusy</a>, <a class="el" href="adc_8c-source.html#l00084">adcUnion::adcByte</a>, <a class="el" href="adc_8c-source.html#l00096">adcChannel</a>, <a class="el" href="adc_8c-source.html#l00092">adcDataValid</a>, <a class="el" href="adc_8c-source.html#l00083">adcUnion::adcInt</a>, <a class="el" href="adc_8c-source.html#l00097">adcMode</a>, <a class="el" href="adc_8c-source.html#l00098">adcScanMask</a>, <a class="el" href="adc_8c-source.html#l00095">adcValue</a>, <a class="el" href="adc_8c-source.html#l00067">FALSE</a>, <a class="el" href="adc_8h-source.html#l00045">FREERUN</a>, <a class="el" href="adc_8h-source.html#l00186">inb</a>, <a class="el" href="adc_8h-source.html#l00191">sbi</a>, <a class="el" href="adc_8h-source.html#l00197">SLEEP_REG</a>, and <a class="el" href="adc_8c-source.html#l00469">writeAdmux()</a>.
</div>
</div><p>
<a class="anchor" name="20694d180636e2fefc77d6ea4f8a61b1"></a><!-- doxytag: member="adc.c::writeAdmux" ref="20694d180636e2fefc77d6ea4f8a61b1" args="(uint8_t channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void writeAdmux           </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write the current ADC channel to the Multiplexer register. 
<p>
The other bits of the register are unchanged.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>ADC Channel number </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="adc_8c-source.html#l00469">469</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
References <a class="el" href="adc_8h-source.html#l00186">inb</a>, and <a class="el" href="adc_8h-source.html#l00188">outb</a>.
<p>
Referenced by <a class="el" href="adc_8c-source.html#l00321">adcRead()</a>, <a class="el" href="adc_8c-source.html#l00220">adcStart()</a>, and <a class="el" href="adc_8c-source.html#l00415">SIGNAL()</a>.
</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="6991c7bbcce4aad43a90312fccdde87f"></a><!-- doxytag: member="adc.c::adc" ref="6991c7bbcce4aad43a90312fccdde87f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unionadcUnion.html">adcUnion</a>  <a class="el" href="adc_8c.html#6991c7bbcce4aad43a90312fccdde87f">adc</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variable to carry the ADC result in a 16 bit word, accessible also as two bytes. 
<p>
Referenced by <a class="el" href="adc_8c-source.html#l00321">adcRead()</a>, and <a class="el" href="adc_8c-source.html#l00415">SIGNAL()</a>.
</div>
</div><p>
<a class="anchor" name="dd7e48743af8fbde7e615a5f46a98bfc"></a><!-- doxytag: member="adc.c::adcBusy" ref="dd7e48743af8fbde7e615a5f46a98bfc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint8_t <a class="el" href="adc_8c.html#dd7e48743af8fbde7e615a5f46a98bfc">adcBusy</a> = FALSE<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
ADC busy flag. 
<p>
Definition at line <a class="el" href="adc_8c-source.html#l00093">93</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
Referenced by <a class="el" href="adc_8c-source.html#l00130">adcInit()</a>, <a class="el" href="adc_8c-source.html#l00293">adcIsBusy()</a>, <a class="el" href="adc_8c-source.html#l00321">adcRead()</a>, <a class="el" href="adc_8c-source.html#l00220">adcStart()</a>, and <a class="el" href="adc_8c-source.html#l00415">SIGNAL()</a>.
</div>
</div><p>
<a class="anchor" name="4cda2ae0c5ac82065b23cadd4843a34b"></a><!-- doxytag: member="adc.c::adcChannel" ref="4cda2ae0c5ac82065b23cadd4843a34b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint8_t <a class="el" href="adc_8c.html#4cda2ae0c5ac82065b23cadd4843a34b">adcChannel</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Current Channel. 
<p>
Definition at line <a class="el" href="adc_8c-source.html#l00096">96</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
Referenced by <a class="el" href="adc_8c-source.html#l00321">adcRead()</a>, <a class="el" href="adc_8c-source.html#l00220">adcStart()</a>, and <a class="el" href="adc_8c-source.html#l00415">SIGNAL()</a>.
</div>
</div><p>
<a class="anchor" name="883a2c17ff3bb2ba7657edfdbca16c51"></a><!-- doxytag: member="adc.c::adcDataValid" ref="883a2c17ff3bb2ba7657edfdbca16c51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint8_t <a class="el" href="adc_8c.html#883a2c17ff3bb2ba7657edfdbca16c51">adcDataValid</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask of channels with valid converted data at any point of a conversion occurring on a group of channels. This is used when the user requests converted data, to indicate that there is indeed a conversion result available for collection. Each bit is set by the ISR when conversion completes for the corresponding channel, and is cleared when the result is read by the user. 
<p>
Definition at line <a class="el" href="adc_8c-source.html#l00092">92</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
Referenced by <a class="el" href="adc_8c-source.html#l00321">adcRead()</a>, <a class="el" href="adc_8c-source.html#l00220">adcStart()</a>, and <a class="el" href="adc_8c-source.html#l00415">SIGNAL()</a>.
</div>
</div><p>
<a class="anchor" name="eba44105ae8656f3c7dff15b852af986"></a><!-- doxytag: member="adc.c::adcMode" ref="eba44105ae8656f3c7dff15b852af986" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint8_t <a class="el" href="adc_8c.html#eba44105ae8656f3c7dff15b852af986">adcMode</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Temporary mode variable. 
<p>
Definition at line <a class="el" href="adc_8c-source.html#l00097">97</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
Referenced by <a class="el" href="adc_8c-source.html#l00130">adcInit()</a>, <a class="el" href="adc_8c-source.html#l00321">adcRead()</a>, <a class="el" href="adc_8c-source.html#l00220">adcStart()</a>, and <a class="el" href="adc_8c-source.html#l00415">SIGNAL()</a>.
</div>
</div><p>
<a class="anchor" name="2d2c09f30fb85b71f5b4cb23437325ab"></a><!-- doxytag: member="adc.c::adcScanMask" ref="2d2c09f30fb85b71f5b4cb23437325ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint8_t <a class="el" href="adc_8c.html#2d2c09f30fb85b71f5b4cb23437325ab">adcScanMask</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Temporary channel mask. 
<p>
Definition at line <a class="el" href="adc_8c-source.html#l00098">98</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
Referenced by <a class="el" href="adc_8c-source.html#l00321">adcRead()</a>, <a class="el" href="adc_8c-source.html#l00220">adcStart()</a>, and <a class="el" href="adc_8c-source.html#l00415">SIGNAL()</a>.
</div>
</div><p>
<a class="anchor" name="b889735af2869e3ce02c3a027b348e94"></a><!-- doxytag: member="adc.c::adcValue" ref="b889735af2869e3ce02c3a027b348e94" args="[NUMBER_OF_ADC_CHANNELS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint16_t <a class="el" href="adc_8c.html#b889735af2869e3ce02c3a027b348e94">adcValue</a>[NUMBER_OF_ADC_CHANNELS]<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Result Buffer. 
<p>
Definition at line <a class="el" href="adc_8c-source.html#l00095">95</a> of file <a class="el" href="adc_8c-source.html">adc.c</a>.
<p>
Referenced by <a class="el" href="adc_8c-source.html#l00321">adcRead()</a>, and <a class="el" href="adc_8c-source.html#l00415">SIGNAL()</a>.
</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Sep 23 14:10:16 2007 for AVR A/D Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
